
MODULE kinetic

! This module provides basic variables and arrays for FFT definition
! of kinetic energand Coulomb solver. Valid for FFTw3 as well as NETLIB.

#if(fftw_cpu)
  USE, INTRINSIC :: iso_c_binding
#endif
  USE params, ONLY: DP, numthr, PI
  IMPLICIT NONE

  SAVE
! Arrays for kinetic energy and electronic propagation.
! Kinetic energy coefficients in strange ordered Fourier space
! akv = Fourier-field for 0.5*k^2
! ak = Fourier-field for exp(i*dt*(h^2/2m)*k^2)

  INTEGER, PRIVATE, ALLOCATABLE :: modx(:), mody(:), modz(:)
  COMPLEX(DP), PARAMETER, PRIVATE :: eye = (0D0, 1D0)

  INTEGER, PRIVATE :: kfft, kfft2, kdfull2
  INTEGER, PRIVATE :: kxmax, kymax, kzmax
  INTEGER, PRIVATE :: iret

  REAL(DP), ALLOCATABLE :: akv(:), akv3D(:, :, :)
  COMPLEX(DP), ALLOCATABLE :: akx(:), aky(:), akz(:) !DB
  COMPLEX(DP), ALLOCATABLE :: akpropx(:), akpropy(:), akpropz(:), akprop(:, :, :)
  COMPLEX(DP), ALLOCATABLE :: ak(:)

#if(netlib_fft)
  COMPLEX(DP), ALLOCATABLE, TARGET :: cfftax(:), cfftay(:), cfftaz(:)
  REAL(DP), PRIVATE, POINTER :: fftax(:), fftay(:), fftaz(:), fftb(:, :) ! Complexes stored in real arrays for NETLIB FFT library
  REAL(DP), PRIVATE, ALLOCATABLE :: wrkx(:), wrky(:), wrkz(:)
  REAL(DP), PRIVATE, ALLOCATABLE :: wsavex(:), wsavey(:), wsavez(:)
  INTEGER, PRIVATE, ALLOCATABLE :: ifacx(:), ifacy(:), ifacz(:)
#endif

#if(fftw_cpu)
  INTEGER, PUBLIC, SAVE :: FFTW_planflag
  COMPLEX(C_DOUBLE_COMPLEX), PRIVATE, ALLOCATABLE :: fftax(:), fftay(:), fftaz(:), fftb(:, :)
  COMPLEX(C_DOUBLE_COMPLEX), PRIVATE, ALLOCATABLE :: ffta(:, :, :, :)
  TYPE(C_PTR), PRIVATE :: pforwx, pforwy, pforwz, pforwz1, pbackx, pbacky, pbackz, pbackz1
  TYPE(C_PTR), PRIVATE, ALLOCATABLE :: pforw(:), pback(:)
  INTEGER(C_INT), PRIVATE :: wisdomtest
#endif

!#if(omp)
  INTEGER, PRIVATE, SAVE :: nacthr
!#endif

CONTAINS
!-----init_grid_fft-----------------------------------------------------

  SUBROUTINE init_grid_fft(dx0, dy0, dz0, nx0, ny0, nz0, dt1, h2m)

! Initialize details for FFT, plans for FFTW3.
!
! Input:
! dx0,dy0,dz0 = grid spacing
! nx0,ny0,nz0 = nr. of grid points
! dt1 = electronic time step
! h2m = electronic hbar*+2/2m

#if(fftw_cpu)
    USE FFTW
#endif
#if(netlib_fft)
    USE, INTRINSIC :: iso_c_binding
#endif
#if(mpi)
    USE params, ONLY: myn, numthr, nthr, mpi_ierror
    INCLUDE 'mpif.h'
    REAL(DP) :: is(mpi_status_size)
#endif

    REAL(DP), INTENT(IN):: dx0, dy0, dz0
    INTEGER, INTENT(IN):: nx0, ny0, nz0
    REAL(DP), INTENT(IN):: dt1, h2m

    INTEGER:: nx, nx2, ny, ny2, nz, nz2
    INTEGER:: i1, i2, i3
    REAL(DP):: dkx, dky, dkz, facnr
    REAL(DP):: zkx, zky, zkz

#if(fftw_cpu)
    INTEGER, SAVE :: nxini = 0, nyini = 0, nzini = 0, nini = 0 ! flag for initialization
    INTEGER :: i
#endif

    INTEGER:: ind

#if(omp)
#if(!dynomp)
    INTEGER :: omp_get_num_threads
#endif
#endif
    nx2 = nx0; ny2 = ny0; nz2 = nz0
    kxmax = nx0; kymax = ny0; kzmax = nz0
    nx = nx2/2; ny = ny2/2; nz = nz2/2

    kfft = 2*kxmax
    kfft2 = kfft*2 + 1
    kdfull2 = kxmax*kymax*kzmax

    dkx = pi/(dx0*nx)
    dky = pi/(dy0*ny)
    dkz = pi/(dz0*nz)

    ALLOCATE (modx(kxmax), mody(kymax), modz(kzmax))
#if(netlib_fft)
    ALLOCATE (ak(kdfull2), akv(kdfull2))
    ALLOCATE (akx(kdfull2), aky(kdfull2), akz(kdfull2)) !DB
    ALLOCATE (akpropx(kxmax), akpropy(kymax), akpropz(kzmax))
    ALLOCATE (akprop(kxmax, kymax, kzmax))
    ALLOCATE (fftax(2*kxmax), fftay(2*kymax), fftaz(2*kzmax), fftb(2*kzmax, kxmax))
    ALLOCATE (wrkx(kfft2), wrky(kfft2), wrkz(kfft2))
    ALLOCATE (wsavex(kfft2), wsavey(kfft2), wsavez(kfft2))
    ALLOCATE (ifacx(kfft2), ifacy(kfft2), ifacz(kfft2))
    ALLOCATE (cfftax(1:nx2), cfftay(1:ny2), cfftaz(1:nz2))
    CALL c_f_pointer(c_loc(cfftax), fftax, [2*nx2])
    CALL c_f_pointer(c_loc(cfftay), fftay, [2*ny2])
    CALL c_f_pointer(c_loc(cfftaz), fftaz, [2*nz2])
#endif
#if(fftw_cpu)
    ALLOCATE (ak(kdfull2), akv(kdfull2))
    ALLOCATE (akx(kdfull2), aky(kdfull2), akz(kdfull2)) !DB
    ALLOCATE (akpropx(kxmax), akpropy(kymax), akpropz(kzmax))
    ALLOCATE (akprop(kxmax, kymax, kzmax))
    ALLOCATE (akv3D(kxmax, kymax, kzmax))
    WRITE (*, *) ' ALLOCATE with: kxmax,kymax,kzmax=', kxmax, kymax, kzmax
    ALLOCATE (fftax(kxmax), fftay(kymax), fftaz(kzmax), fftb(kzmax, kxmax))
#if(omp)
    nacthr = numthr - 1
#else
    nacthr = 0
#endif
    ALLOCATE (ffta(kxmax, kymax, kzmax, 0:nacthr), pforw(0:nacthr), pback(0:nacthr))
    WRITE (*, *) ' FFTA allocated with NACTHR=', nacthr
!
! central setting of FFTW planning expense --> edit here
!
! FFTW_planflag = FFTW_MEASURE
    FFTW_planflag = FFTW_PATIENT
! FFTW_planflag = FFTW_EXHAUSTIVE
#endif

    WRITE (7, *) 'h bar squared over two m electron', h2m
    WRITE (7, *) ' testprint EYE=', eye
    WRITE (7, *) ' dkx,dky,dkz=', dkx, dky, dkz
    WRITE (7, *) ' testprint: nx2,ny2,nz2=', nx2, ny2, nz2
    WRITE (7, *) ' testprint: kdfull2,kfft2=', kdfull2, kfft2

! prepare k**2 and kinetic propagation factor in 3D momentum space
    facnr = 1D0/(nx2*ny2*nz2)
    ind = 0
    DO i3 = 1, nz2
      IF (i3 >= (nz + 1)) THEN
        zkz = (i3 - nz2 - 1)*dkz
      ELSE
        zkz = (i3 - 1)*dkz
      END IF
      DO i2 = 1, ny2
        IF (i2 >= (ny + 1)) THEN
          zky = (i2 - ny2 - 1)*dky
        ELSE
          zky = (i2 - 1)*dky
        END IF
        DO i1 = 1, nx2
          IF (i1 >= (nx + 1)) THEN
            zkx = (i1 - nx2 - 1)*dkx
          ELSE
            zkx = (i1 - 1)*dkx
          END IF
          ind = ind + 1
          ak(ind) = EXP(-eye*dt1*(zkx**2 + zky**2 + zkz**2)*h2m)
          akv(ind) = (zkx**2 + zky**2 + zkz**2)*h2m
          akx(ind) = zkx!*facnr
          aky(ind) = zky!*facnr
          akz(ind) = zkz!*facnr
#if(fftw_cpu)
          akprop(i1, i2, i3) = ak(ind)*facnr
          akv3D(i1, i2, i3) = akv(ind)*facnr
#else
          akprop(i1, i2, i3) = ak(ind)
#endif
        END DO
      END DO
    END DO

! prepare kinetic propagation factors in 1D momentum spaces

    DO i3 = 1, nz2
      IF (i3 >= (nz + 1)) THEN
        zkz = (i3 - nz2 - 1)*dkz
      ELSE
        zkz = (i3 - 1)*dkz
      END IF
      akpropz(i3) = EXP(-eye*dt1*zkz**2*h2m)
    END DO

    DO i2 = 1, ny2
      IF (i2 >= (ny + 1)) THEN
        zky = (i2 - ny2 - 1)*dky
      ELSE
        zky = (i2 - 1)*dky
      END IF
      akpropy(i2) = EXP(-eye*dt1*zky**2*h2m)
    END DO

    DO i1 = 1, nx2
      IF (i1 >= (nx + 1)) THEN
        zkx = (i1 - nx2 - 1)*dkx
      ELSE
        zkx = (i1 - 1)*dkx
      END IF
      akpropx(i1) = EXP(-eye*dt1*zkx**2*h2m)
    END DO

! compose to kinetic propagation factors in 3D momentum spaces

    DO i3 = 1, nz2; DO i2 = 1, ny2; DO i1 = 1, nx2
          akprop(i1, i2, i3) = akpropx(i1)*akpropy(i2)*akpropz(i3)
        END DO; END DO; END DO
#if(fftw_cpu)
    akprop(:, :, :) = akprop(:, :, :)*facnr
#endif

! book-keeping arrays
    DO i1 = 1, nx2
      modx(i1) = MOD(i1 + nx, nx2) + 1
    END DO
    DO i2 = 1, ny2
      mody(i2) = MOD(i2 + ny, ny2) + 1
    END DO
    DO i3 = 1, nz2
      modz(i3) = MOD(i3 + nz, nz2) + 1
    END DO

#if(extended)
! preparation of arrays for netlib
!#if(netlib_fft)
! ALLOCATE(fftax(2*kxmax),fftay(2*kymax),fftb(2*kzmax,kxmax))
! ALLOCATE(wrkx(kfft2),wrky(kfft2),wrkz(kfft2))
! ALLOCATE(wsavex(kfft2),wsavey(kfft2),wsavez(kfft2))
! ALLOCATE(ifacx(kfft2),ifacy(kfft2),ifacz(kfft2))
!#endif
! END of netlib switch
#endif

#if(fftw_cpu)
! FFTW3 switch, preparation of 'plans'

#if(extended)
! WRITE(*,*) ' ALLOCATE with: kxmax,kymax,kzmax=',kxmax,kymax,kzmax
! ALLOCATE(fftax(kxmax),fftay(kymax),fftaz(kzmax),fftb(kzmax,kxmax))
#endif
#if(omp)
    nacthr = numthr - 1
#else
    nacthr = 0
#endif
#if(extended)
! ALLOCATE(ffta(kxmax,kymax,kzmax,0:nacthr),pforw(0:nacthr),pback(0:nacthr))
! WRITE(*,*) ' FFTA allocated with NACTHR=',nacthr
#endif
    !
    ! central setting of FFTW planning expense --> edit here
    !
    FFTW_planflag = FFTW_MEASURE
    ! FFTW_planflag = FFTW_PATIENT
    ! FFTW_planflag = FFTW_EXHAUSTIVE

#if(nompi)
#if(omp)
#if(!dynomp)
    CALL dfftw_init_threads(iret)
    WRITE (*, *) ' dfftw_init_threads: iret=', iret
    CALL dfftw_plan_with_nthreads(numthr)
    WRITE (*, *) ' init fft FFTW threads: nr. of threads=', numthr
#endif
#endif
    IF (nini == 0) THEN
#if(fftwnomkl)
      wisdomtest = fftw_import_wisdom_from_filename(C_CHAR_'wisdom_fftw.dat'//C_NULL_CHAR)
#endif
      IF (wisdomtest == 0) THEN
        wisdomtest = fftw_import_system_wisdom()
        IF (wisdomtest == 0) THEN
          WRITE (6, *) 'wisdom_fftw.dat not found, creating it'
          WRITE (7, *) 'wisdom_fftw.dat not found, creating it'
        ELSE
          WRITE (*, *) 'wisdom from system'
        END IF
      END IF

      ! initialitze 3D plans, take care for independence in OpenMP
      DO i = 0, nacthr
        pforw(i) = fftw_plan_dft_3d(nz2, ny2, nx2, ffta(:, :, :, i), ffta(:, :, :, i), &
                                    FFTW_FORWARD, FFTW_planflag)
        pback(i) = fftw_plan_dft_3d(nz2, ny2, nx2, ffta(:, :, :, i), ffta(:, :, :, i), &
                                    FFTW_BACKWARD, FFTW_planflag)
      END DO
      nini = nx2*ny2*nz2
      WRITE (*, *) ' initialized nini=', nini, nx2, ny2, nz2
    ELSE IF (nini /= nx2*ny2*nz2) THEN
      WRITE (*, *) ' nini,nx2,ny2,nz2=', nini, nx2, ny2, nz2
      STOP ' nx2, ny2 or/and nz2 in four3d not as initialized!'
    END IF
    IF (nxini == 0) THEN
      pforwx = fftw_plan_dft_1d(nx2, fftax, fftax, FFTW_FORWARD, FFTW_planflag)
      pbackx = fftw_plan_dft_1d(nx2, fftax, fftax, FFTW_BACKWARD, FFTW_planflag)
      nxini = nx2
    ELSE IF (nxini /= nx2) THEN
      STOP ' nx2 in four3d not as initialized!'
    END IF
    IF (nyini == 0) THEN
      pforwy = fftw_plan_dft_1d(ny2, fftay, fftay, FFTW_FORWARD, FFTW_planflag)
      pbacky = fftw_plan_dft_1d(ny2, fftay, fftay, FFTW_BACKWARD, FFTW_planflag)
      nyini = ny2
    ELSE IF (nyini /= ny2) THEN
      STOP ' ny2 in four3d not as initialized!'
    END IF
    IF (nzini == 0) THEN
      pforwz = fftw_plan_dft_1d(nz2, fftb(1, nx2), fftb(1, nx2), FFTW_FORWARD, &
                                FFTW_planflag)
      pbackz = fftw_plan_dft_1d(nz2, fftb(1, nx2), fftb(1, nx2), FFTW_BACKWARD, &
                                FFTW_planflag)
      pforwz1 = fftw_plan_dft_1d(nz2, fftaz, fftaz, FFTW_FORWARD, FFTW_planflag)
      pbackz1 = fftw_plan_dft_1d(nz2, fftaz, fftaz, FFTW_BACKWARD, FFTW_planflag)
      nzini = nz2
    ELSE IF (nzini /= nz2) THEN
      STOP ' nz2 in four3d not as initialized!'
    END IF
#if(fftwnomkl)
    wisdomtest = fftw_export_wisdom_to_filename(C_CHAR_'wisdom_fftw.dat'//C_NULL_CHAR)
#endif
    IF (wisdomtest == 0) THEN
      WRITE (6, *) 'Error exporting wisdom to FILE wisdom_fftw.dat'
      WRITE (7, *) 'Error exporting wisdom to FILE wisdom_fftw.dat'
    ELSE
      WRITE (*, *) ' suuccessfull export of wisdom to wisdom_fftw.dat'
    END IF
    CALL fftw_forget_wisdom
#endif

#if(mpi)
    IF (nini == 0) THEN
      IF (myn == 0) THEN
        !Master node creates wisdom IF necessary...
#if(fftwnomkl)
        wisdomtest = fftw_import_wisdom_from_filename(C_CHAR_'wisdom_fftw.dat'//C_NULL_CHAR)
#endif
        IF (wisdomtest == 0) THEN
          WRITE (6, *) 'wisdom_fftw.dat not found, creating it'
          WRITE (7, *) 'wisdom_fftw.dat not found, creating it'
        END IF
        pforw(0) = fftw_plan_dft_3d(nz2, ny2, nx2, ffta(:, :, :, 0), ffta(:, :, :, 0), &
                                    FFTW_FORWARD, FFTW_planflag)
        pback(0) = fftw_plan_dft_3d(nz2, ny2, nx2, ffta(:, :, :, 0), ffta(:, :, :, 0), &
                                    FFTW_BACKWARD, FFTW_planflag)
        nini = nx2*ny2*nz2
#if(fftwnomkl)
        wisdomtest = fftw_export_wisdom_to_filename(C_CHAR_'wisdom_fftw.dat'//C_NULL_CHAR)
#endif
        IF (wisdomtest == 0) THEN
          WRITE (6, *) 'Error exporting wisdom to FILE wisdom_fftw.dat'
          WRITE (7, *) 'Error exporting wisdom to FILE wisdom_fftw.dat'
        END IF
      END IF
      CALL mpi_barrier(mpi_comm_world, mpi_ierror)
      !... THEN other nodes use it
      IF (myn /= 0) THEN
#if(fftwnomkl)
        wisdomtest = fftw_import_wisdom_from_filename(C_CHAR_'wisdom_fftw.dat'//C_NULL_CHAR)
#endif
        pforw(0) = fftw_plan_dft_3d(nz2, ny2, nx2, ffta(:, :, :, 0), ffta(:, :, :, 0), &
                                    FFTW_FORWARD, FFTW_planflag)
        pback(0) = fftw_plan_dft_3d(nz2, ny2, nx2, ffta(:, :, :, 0), ffta(:, :, :, 0), &
                                    FFTW_BACKWARD, FFTW_planflag)
        nini = nx2*ny2*nz2
      END IF
    ELSE IF (nini /= nx2*ny2*nz2) THEN
      STOP ' nx2, ny2 or/and nz2 in four3d not as initialized!'
    END IF
    IF (nxini == 0) THEN
      IF (myn == 0) THEN
        pforwx = fftw_plan_dft_1d(nx2, fftax, fftax, FFTW_FORWARD, FFTW_planflag)
        pbackx = fftw_plan_dft_1d(nx2, fftax, fftax, FFTW_BACKWARD, FFTW_planflag)
        nxini = nx2
#if(fftwnomkl)
        wisdomtest = fftw_export_wisdom_to_filename(C_CHAR_'wisdom_fftw.dat'//C_NULL_CHAR)
#endif
        IF (wisdomtest == 0) THEN
          WRITE (6, *) 'Error exporting wisdom to FILE wisdom_fftw.dat'
          WRITE (7, *) 'Error exporting wisdom to FILE wisdom_fftw.dat'
        END IF
      END IF
      CALL mpi_barrier(mpi_comm_world, mpi_ierror)
      IF (myn /= 0) THEN
#if(fftwnomkl)
        wisdomtest = fftw_import_wisdom_from_filename(C_CHAR_'wisdom_fftw.dat'//C_NULL_CHAR)
#endif
        pforwx = fftw_plan_dft_1d(nx2, fftax, fftax, FFTW_FORWARD, FFTW_planflag)
        pbackx = fftw_plan_dft_1d(nx2, fftax, fftax, FFTW_BACKWARD, FFTW_planflag)
        nxini = nx2
      END IF
    ELSE IF (nxini /= nx2) THEN
      STOP ' nx2 in four3d not as initialized!'
    END IF
    IF (nyini == 0) THEN
      IF (myn == 0) THEN
        pforwy = fftw_plan_dft_1d(ny2, fftay, fftay, FFTW_FORWARD, FFTW_planflag)
        pbacky = fftw_plan_dft_1d(ny2, fftay, fftay, FFTW_BACKWARD, FFTW_planflag)
        nyini = ny2
#if(fftwnomkl)
        wisdomtest = fftw_export_wisdom_to_filename(C_CHAR_'wisdom_fftw.dat'//C_NULL_CHAR)
#endif
        IF (wisdomtest == 0) THEN
          WRITE (6, *) 'Error exporting wisdom to FILE wisdom_fftw.dat'
          WRITE (7, *) 'Error exporting wisdom to FILE wisdom_fftw.dat'
        END IF
      END IF
      CALL mpi_barrier(mpi_comm_world, mpi_ierror)
      IF (myn /= 0) THEN
#if(fftwnomkl)
        wisdomtest = fftw_import_wisdom_from_filename(C_CHAR_'wisdom_fftw.dat'//C_NULL_CHAR)
#endif
        pforwy = fftw_plan_dft_1d(ny2, fftay, fftay, FFTW_FORWARD, FFTW_planflag)
        pbacky = fftw_plan_dft_1d(ny2, fftay, fftay, FFTW_BACKWARD, FFTW_planflag)
        nyini = ny2
      END IF
    ELSE IF (nyini /= ny2) THEN
      STOP ' ny2 in four3d not as initialized!'
    END IF
    IF (nzini == 0) THEN
      IF (myn == 0) THEN
        pforwz = fftw_plan_dft_1d(nz2, fftb(1, nx2), fftb(1, nx2), &
                                  FFTW_FORWARD, FFTW_planflag)
        pbackz = fftw_plan_dft_1d(nz2, fftb(1, nx2), fftb(1, nx2), &
                                  FFTW_BACKWARD, FFTW_planflag)
        pforwz1 = fftw_plan_dft_1d(nz2, fftaz, fftaz, FFTW_FORWARD, FFTW_planflag)
        pbackz1 = fftw_plan_dft_1d(nz2, fftaz, fftaz, FFTW_BACKWARD, FFTW_planflag)
        nzini = nz2
#if(fftwnomkl)
        wisdomtest = fftw_export_wisdom_to_filename(C_CHAR_'wisdom_fftw.dat'//C_NULL_CHAR)
#endif
        IF (wisdomtest == 0) THEN
          WRITE (6, *) 'Error exporting wisdom to FILE wisdom_fftw.dat'
          WRITE (7, *) 'Error exporting wisdom to FILE wisdom_fftw.dat'
        END IF
      END IF
      CALL mpi_barrier(mpi_comm_world, mpi_ierror)
      IF (myn /= 0) THEN
#if(fftwnomkl)
        wisdomtest = fftw_import_wisdom_from_filename(C_CHAR_'wisdom_fftw.dat'//C_NULL_CHAR)
#endif
        pforwz = fftw_plan_dft_1d(nz2, fftb(1, nx2), fftb(1, nx2), &
                                  FFTW_FORWARD, FFTW_planflag)
        pbackz = fftw_plan_dft_1d(nz2, fftb(1, nx2), fftb(1, nx2), &
                                  FFTW_BACKWARD, FFTW_planflag)
        pforwz1 = fftw_plan_dft_1d(nz2, fftaz, fftaz, FFTW_FORWARD, FFTW_planflag)
        pbackz1 = fftw_plan_dft_1d(nz2, fftaz, fftaz, FFTW_BACKWARD, FFTW_planflag)
        nzini = nz2
      END IF
    ELSE IF (nzini /= nz2) THEN
      STOP ' nz2 in four3d not as initialized!'
    END IF
#endif

! END of FFTW3 switch
#endif

  END SUBROUTINE init_grid_fft

#if(fftw_cpu)
! ******************************

  SUBROUTINE kinprop(q1)

! ******************************

! Propagation with kinetic energy exp(-i*dt*e_kin).
!
! Input/Output:
! q1 = coordinate-space array for propagated wavefunction

    USE params
    USE FFTW

    IMPLICIT NONE

    COMPLEX(DP), INTENT(IN OUT) :: q1(kxbox, kybox, kzbox)
!COMPLEX(DP), INTENT(OUT) :: q2(kdfull2)

    COMPLEX(DP), ALLOCATABLE :: ffttax(:), ffttay(:), ffttaz(:), ffttb(:, :)
!REAL(DP)::facnr
    INTEGER :: ithr
!REAL(DP):: tnorm, xfnorm, yfnorm, zfnorm

    LOGICAL, PARAMETER :: ttimestop = .FALSE.
    REAL(DP) :: acctime(0:2) = (/0D0, 0D0, 0D0/)
    INTEGER :: it1, it2, it3, it4, it5, it6

!tnorm=1D0/SQRT(8D0*pi*pi*pi*REAL(nx2*ny2*nz2,DP))

    ithr = 0
#if(omp)
#if(dynomp)
    ithr = OMP_GET_THREAD_NUM()
    IF (ithr > nacthr) THEN
      WRITE (*, *) ' in kinprop: ithr,nacthr=', ithr, nacthr
      STOP "too large ITHR"
    END IF
#endif
#endif
!facnr = 1D0/(nx2*ny2*nz2)

    IF (ttimestop) CALL system_clock(it1)
    IF (ttimestop) CALL system_clock(it2)
    CALL fftw_execute_dft(pforw(ithr), q1, q1)
    IF (ttimestop) CALL system_clock(it3)
    q1 = akprop*q1
    IF (ttimestop) CALL system_clock(it4)
    CALL fftw_execute_dft(pback(ithr), q1, q1)
    IF (ttimestop) CALL system_clock(it5)
    IF (ttimestop) THEN
      CALL system_clock(it6)
      acctime(0) = acctime(0) + 1D0
      acctime(1) = acctime(1) + (it4 - it3)*systime_factor
      acctime(2) = acctime(2) + (it3 - it2 + it5 - it4)*systime_factor
      IF (MOD(acctime(0), 8D0) == 0D0) WRITE (6, '(a,10(1pg11.3))') &
        'systime4: prop,fft=', acctime(1)/acctime(0), acctime(2)/acctime(0)
    END IF

    RETURN

  END SUBROUTINE kinprop
! ******************************

  SUBROUTINE kinetic_energy(q1, q2)

! ******************************

! ACTION of the kinetic energy
!
! Input/Output:
! q1 = coordinate-space array for propagated wavefunction

    USE params
    USE FFTW

    IMPLICIT NONE

    COMPLEX(DP), INTENT(IN) :: q1(kdfull2)
    COMPLEX(DP), INTENT(OUT) :: q2(kdfull2)

#if(extended)
!COMPLEX(DP), ALLOCATABLE :: ffttax(:),ffttay(:),ffttaz(:),ffttb(:,:)
!REAL(DP)::facnr
!REAL(DP):: tnorm, xfnorm, yfnorm, zfnorm
!LOGICAL,PARAMETER :: ttimestop=.FALSE.
!REAL(DP) :: acctime(0:2)=(/0D0,0D0,0D0/)
!INTEGER :: it1,it2,it3,it4,it5,it6
#endif

    INTEGER :: ithr
    COMPLEX(DP), ALLOCATABLE :: qwork(:, :, :)

#if(extended)
!tnorm=1D0/SQRT(8D0*pi*pi*pi*REAL(nx2*ny2*nz2,DP))
#endif

    ithr = 0
#if(omp)
#if(dynomp)
    ithr = OMP_GET_THREAD_NUM()
    IF (ithr > nacthr) THEN
      WRITE (*, *) ' in kinetic_energy: ithr,nacthr=', ithr, nacthr
      STOP "too large ITHR"
    END IF
#endif
#endif
#if(extended)
!facnr = 1D0/(nx2*ny2*nz2)
#endif

    ALLOCATE (qwork(kxbox, kybox, kzbox))
    CALL copy1dto3d(q1, qwork, nx2, ny2, nz2)
    CALL fftw_execute_dft(pforw(ithr), qwork, qwork)
    qwork = akv3D*qwork
    CALL fftw_execute_dft(pback(ithr), qwork, qwork)
    CALL secopy3dto1d(qwork, q2, 1D0, nx2, ny2, nz2)
    DEALLOCATE (qwork)

    RETURN

  END SUBROUTINE kinetic_energy
#endif

  SUBROUTINE calc_ekin(psin, ekinout)

! Calculates kinetic energy for single particle state with
! complex wavefunction 'psin'.

    USE params
    IMPLICIT NONE

    COMPLEX(DP), INTENT(IN) :: psin(kdfull2)
    REAL(DP), INTENT(OUT) :: ekinout

    REAL(DP) :: sum0
    REAL(DP) :: sumk, sum0ex
    INTEGER ::ii
    REAL(DP) :: vol
    COMPLEX(DP), DIMENSION(:), ALLOCATABLE :: psi2

!------------------------------------------------------------------

    ALLOCATE (psi2(kdfull2))

    CALL fftf(psin, psi2)
    sum0 = 0D0
    sumk = 0D0
    DO ii = 1, kdfull2
      vol = REAL(psi2(ii), DP)*REAL(psi2(ii), DP) + AIMAG(psi2(ii))*AIMAG(psi2(ii))
      sum0 = vol + sum0
      sumk = vol*akv(ii) + sumk
    END DO
    sum0ex = 1D0/((2D0*PI)**3*dx*dy*dz)
    ekinout = sumk/sum0ex

    DEALLOCATE (psi2)

    RETURN
  END SUBROUTINE calc_ekin

! ******************************

  SUBROUTINE gradient(fin, gradfout, idirec)

! The gradient of complex field 'fin' in direction 'idirec'
! (x =1, y=2, z=3).
! The fields are given in Fourier space and the gradient is
! applied as product with 'kx', 'ky', 'kz'.
!

    USE params
    IMPLICIT NONE

    COMPLEX(DP), INTENT(IN) :: fin(kdfull2)
    COMPLEX(DP), INTENT(OUT) :: gradfout(kdfull2)
    INTEGER, INTENT(IN) :: idirec

! ************************************************************

    IF (idirec == 1) THEN
! x-derivative
      gradfout = -akx*fin
    ELSEIF (idirec == 2) THEN
! y-derivative
      gradfout = -aky*fin
    ELSEIF (idirec == 3) THEN
! z-derivative
      gradfout = -akz*fin
    ELSE
      STOP ' RGRADIENT called with invalid IDIREC'
    END IF

    RETURN
  END SUBROUTINE gradient

#if(fftw_cpu)
! BLOCK of subroutines for FFTW3
! ******************************

  SUBROUTINE xgradient_rspace(fin, gradfout)

! The gradient of the complex field 'fin' in x-direction.
! The fields are given in coordinate space. The gradient is
! evaluated in k_x space.
!

    USE params
    USE FFTW
    IMPLICIT NONE

    COMPLEX(DP), INTENT(IN) :: fin(kdfull2)
    COMPLEX(DP), INTENT(OUT) :: gradfout(kdfull2)

    INTEGER:: i1, i2, i3, ind
    REAL(DP):: dkx, zkx
! ************************************************************

    dkx = pi/(dx*nx)
    DO i3 = 1, nz2
      DO i2 = 1, ny2
! forward transform along x
        DO i1 = 1, nx2
          ind = (i3 - 1)*nxyf + (i2 - 1)*nyf + i1
          fftax(modx(i1)) = fin(ind) ! copy to workspace
        END DO
        CALL fftw_execute_dft(pforwx, fftax, fftax) ! basic fft
! multiply by k_x factor in k_x space
        DO i1 = 1, nx2
          IF (i1 == (nx + 1)) THEN
            zkx = 0D0
          ELSE IF (i1 > (nx + 1)) THEN
            zkx = (i1 - nx2 - 1)*dkx
          ELSE
            zkx = (i1 - 1)*dkx
          END IF
          fftax(i1) = fftax(i1)*eye*zkx
        END DO
! backward transform along x
        CALL fftw_execute_dft(pbackx, fftax, fftax)
        DO i1 = 1, nx2
          ind = (i3 - 1)*nxyf + (i2 - 1)*nyf + i1
          gradfout(ind) = fftax(modx(i1))/nx2
        END DO
      END DO
    END DO

    RETURN

  END SUBROUTINE xgradient_rspace

  SUBROUTINE ygradient_rspace(fin, gradfout)

! The gradient of the complex field 'fin' in y-direction.
! The fields are given in coordinate space. The gradient is
! evaluated in k_y space.
!

    USE params
    USE FFTW
    IMPLICIT NONE

    COMPLEX(DP), INTENT(IN) :: fin(kdfull2)
    COMPLEX(DP), INTENT(OUT) :: gradfout(kdfull2)

    INTEGER:: i1, i2, i3, ind
    REAL(DP):: dky, zky
! ************************************************************

    dky = pi/(dy*ny)
    DO i3 = 1, nz2
      DO i1 = 1, nx2
! forward transform along y
        DO i2 = 1, ny2
          ind = (i3 - 1)*nxyf + (i2 - 1)*nyf + i1
          fftay(mody(i2)) = fin(ind)
        END DO
        CALL fftw_execute_dft(pforwy, fftay, fftay)
! multiply by k_y factor in k_y space
        DO i2 = 1, ny2
          IF (i2 == (ny + 1)) THEN
            zky = 0D0
          ELSE IF (i2 > (ny + 1)) THEN
            zky = (i2 - ny2 - 1)*dky
          ELSE
            zky = (i2 - 1)*dky
          END IF
          fftay(i2) = fftay(i2)*eye*zky
        END DO
! backward transform along y
        CALL fftw_execute_dft(pbacky, fftay, fftay)
        DO i2 = 1, ny2
          ind = (i3 - 1)*nxyf + (i2 - 1)*nyf + i1
          gradfout(ind) = fftay(mody(i2))/ny2
        END DO
      END DO
    END DO

    RETURN

  END SUBROUTINE ygradient_rspace

  SUBROUTINE zgradient_rspace(fin, gradfout)

! The gradient of the complex field 'fin' in z-direction.
! The fields are given in coordinate space. The gradient is
! evaluated in k_z space.
!

    USE params
    USE FFTW
    IMPLICIT NONE

    COMPLEX(DP), INTENT(IN) :: fin(kdfull2)
    COMPLEX(DP), INTENT(OUT) :: gradfout(kdfull2)

    INTEGER:: i1, i2, i3, i3m, ind
    REAL(DP):: dkz, zkz

! ************************************************************

    dkz = pi/(dz*nz)
    DO i2 = 1, ny2
      DO i1 = 1, nx2
! forward transform along z
        DO i3 = 1, nz2
          ind = (i3 - 1)*nxyf + (i2 - 1)*nyf + i1
          i3m = MOD(i3 + nz, nz2) + 1
! i3m = modz(i3)
          fftaz(i3m) = fin(ind)
        END DO
        CALL fftw_execute_dft(pforwz, fftaz, fftaz)
! multiply by k_z factor in k_z space
        DO i3 = 1, nz2
          IF (i3 == (nz + 1)) THEN
            zkz = 0D0
          ELSE IF (i3 > (nz + 1)) THEN
            zkz = (i3 - nz2 - 1)*dkz
          ELSE
            zkz = (i3 - 1)*dkz
          END IF
          fftaz(i3) = fftaz(i3)*eye*zkz
        END DO
! backward transform along z
        CALL fftw_execute_dft(pbackz, fftaz, fftaz)
        DO i3 = 1, nz2 ! copy back
          ind = (i3 - 1)*nxyf + (i2 - 1)*nyf + i1
          i3m = MOD(i3 + nz, nz2) + 1
          gradfout(ind) = fftaz(modz(i3))/nz2
        END DO
!
      END DO
    END DO

    RETURN

  END SUBROUTINE zgradient_rspace

  SUBROUTINE fftf(q1, q2)

! Forward 3D FFT from 'q1' in r-space to 'q2' in k-space.

    USE params
    USE FFTW
    IMPLICIT NONE

    COMPLEX(DP), INTENT(IN) :: q1(kdfull2)
    COMPLEX(DP), INTENT(OUT) :: q2(kdfull2)

    REAL(DP):: tnorm

    tnorm = 1D0/SQRT(8D0*pi*pi*pi*REAL(nx2*ny2*nz2, DP))

    CALL copy1dto3d(q1, ffta(:, :, :, 0), nx2, ny2, nz2)
    CALL fftw_execute_dft(pforw(0), ffta, ffta)
    CALL copy3dto1d(ffta(:, :, :, 0), q2, tnorm, nx2, ny2, nz2)

    RETURN
  END SUBROUTINE fftf

  SUBROUTINE fftback(q1, q2)

! Backward 3D FFT from 'q1' in k-space to 'q2' in r-space.

    USE params
    USE FFTW
    IMPLICIT NONE

    COMPLEX(DP), INTENT(IN) :: q1(kdfull2)
    COMPLEX(DP), INTENT(OUT) :: q2(kdfull2)
    REAL(DP):: facnr

    facnr = SQRT(8D0*pi*pi*pi)/SQRT(REAL(nx2*ny2*nz2, DP))

    CALL secopy1dto3d(q1, ffta(:, :, :, 0), nx2, ny2, nz2)
    CALL fftw_execute_dft(pback(0), ffta(:, :, :, 0), ffta(:, :, :, 0))
    CALL secopy3dto1d(ffta(:, :, :, 0), q2, facnr, nx2, ny2, nz2)

    RETURN
  END SUBROUTINE fftback

  SUBROUTINE rftf(q1, q2)

! Forward 3D FFT from real r-space array 'q1' to complex k-space 'q2'.

    USE params
    USE FFTW
    IMPLICIT NONE

    REAL(DP), INTENT(IN) :: q1(kdfull2)
    COMPLEX(DP), INTENT(OUT) :: q2(kdfull2)

    REAL(DP):: tnorm

    tnorm = 1D0/SQRT(8D0*pi*pi*pi*REAL(nx2*ny2*nz2, DP))

    CALL copyr1dto3d(q1, ffta(:, :, :, 0), nx2, ny2, nz2)
    CALL fftw_execute_dft(pforw(0), ffta(:, :, :, 0), ffta(:, :, :, 0))
    CALL copy3dto1d(ffta(:, :, :, 0), q2, tnorm, nx2, ny2, nz2)

    RETURN
  END SUBROUTINE rftf

  SUBROUTINE rfftback(q1, q3)

! Backward 3D FFT from complex k-space 'q1' to real r-space array 'q3'.

    USE params
    USE FFTW
    IMPLICIT NONE

    COMPLEX(DP), INTENT(IN) :: q1(kdfull2)
    REAL(DP), INTENT(OUT) :: q3(kdfull2)

    REAL(DP):: facnr

#if(extended)
! DATA nxini,nyini,nzini/0,0,0/ ! flag for initialization
! nxyf=nx2*ny2
! nyf=nx2
! nx=nx2/2
! ny=ny2/2
! nz=nz2/2
#endif

    facnr = SQRT(8D0*pi*pi*pi)/SQRT(REAL(nx2*ny2*nz2, DP))

    CALL secopy1dto3d(q1, ffta(:, :, :, 0), nx2, ny2, nz2)
    CALL fftw_execute_dft(pback(0), ffta(:, :, :, 0), ffta(:, :, :, 0))
    CALL copyr3dto1d(ffta(:, :, :, 0), q3, facnr, nx2, ny2, nz2)

    RETURN
  END SUBROUTINE rfftback

  SUBROUTINE copy1dto3d(vec1d, vec3d, nbx2, nby2, nbz2)

! Copies 3D array from linear storage to 3D storage (both COMPLEX).
!
! Input:
! vec1d = array in linear storage
! nbx2,nby2,nbz2 = dimensions of 3D array
! Output:
! vec3d = array in 3D storage

    USE params
    IMPLICIT NONE

    INTEGER, INTENT(IN) :: nbx2
    INTEGER, INTENT(IN) :: nby2
    INTEGER, INTENT(IN) :: nbz2
    COMPLEX(DP), INTENT(IN) :: vec1d(kdfull2)
    COMPLEX(C_DOUBLE_COMPLEX), INTENT(OUT) :: vec3d(nbx2, nby2, nbz2)

    INTEGER:: i1, i2, i3, ind

    ind = 0
    DO i3 = 1, nbz2
      DO i2 = 1, nby2
        DO i1 = 1, nbx2
          ind = ind + 1
          vec3d(i1, i2, i3) = vec1d(ind)
        END DO
      END DO
    END DO

    RETURN
  END SUBROUTINE copy1dto3d

! ******************************

  SUBROUTINE copyr1dto3d(vec1d, vec3d, nbx2, nby2, nbz2)

! Copies 3D array from real & linear storage to complex & 3D storage.
!
! Input:
! vec1d = array in linear storage
! nbx2,nby2,nbz2 = dimensions of 3D array
! Output:
! vec3d = array in 3D storage

    USE params
    IMPLICIT NONE

    INTEGER, INTENT(IN) :: nbx2
    INTEGER, INTENT(IN) :: nby2
    INTEGER, INTENT(IN) :: nbz2
    REAL(DP), INTENT(IN) :: vec1d(kdfull2)
    COMPLEX(C_DOUBLE_COMPLEX), INTENT(OUT) :: vec3d(nbx2, nby2, nbz2)
    INTEGER:: i1, i2, i3, ind

    ind = 0
    DO i3 = 1, nbz2
      DO i2 = 1, nby2
        DO i1 = 1, nbx2
          ind = ind + 1
          vec3d(i1, i2, i3) = CMPLX(vec1d(ind), 0D0, DP)
        END DO
      END DO
    END DO

    RETURN
  END SUBROUTINE copyr1dto3d

! ******************************

  SUBROUTINE secopy1dto3d(vec1d, vec3d, nbx2, nby2, nbz2)

! Copies 3D array from linear storage to 3D storage (both COMPLEX).
!
! Input:
! vec1d = array in linear storage
! nbx2,nby2,nbz2 = dimensions of 3D array
! Output:
! vec3d = array in 3D storage
!
! Does the same as 'copy1dto3d' but with faster (?) index computation.

    USE params
    IMPLICIT NONE

    INTEGER, INTENT(IN) :: nbx2
    INTEGER, INTENT(IN) :: nby2
    INTEGER, INTENT(IN) :: nbz2
    COMPLEX(DP), INTENT(IN) :: vec1d(kdfull2)
    COMPLEX(C_DOUBLE_COMPLEX), INTENT(OUT) :: vec3d(nbx2, nby2, nbz2)
    INTEGER:: i1, i2, i3, ind

    DO i3 = 1, nbz2
      DO i2 = 1, nby2
        DO i1 = 1, nbx2
          ind = (i3 - 1)*nxyf + (i2 - 1)*nyf + i1
          vec3d(i1, i2, i3) = vec1d(ind)
        END DO
      END DO
    END DO

    RETURN
  END SUBROUTINE secopy1dto3d

! ******************************

  SUBROUTINE copy3dto1d(vec3d, vec1d, coef, nbx2, nby2, nbz2)

! Copies 3D array from 3D storage to linear storage (both COMPLEX).
!
! Input:
! vec3d = array in 3D storage
! nbx2,nby2,nbz2 = dimensions of 3D array
! Output:
! vec1d = array in linear storage
!

    USE params
    IMPLICIT NONE

    REAL(DP), INTENT(IN) ::coef
    INTEGER, INTENT(IN) :: nbx2
    INTEGER, INTENT(IN) :: nby2
    INTEGER, INTENT(IN) :: nbz2
    COMPLEX(C_DOUBLE_COMPLEX), INTENT(IN) :: vec3d(nbx2, nby2, nbz2)
    COMPLEX(DP), INTENT(OUT) :: vec1d(kdfull2)
    INTEGER:: i1, i2, i3, ind

    DO i3 = 1, nbz2
      DO i2 = 1, nby2
        DO i1 = 1, nbx2
          ind = (i3 - 1)*nxyf + (i2 - 1)*nyf + i1
          vec1d(ind) = coef*vec3d(i1, i2, i3)
        END DO
      END DO
    END DO

    RETURN
  END SUBROUTINE copy3dto1d

! ******************************

  SUBROUTINE copyr3dto1d(vec3d, vec1d, coef, nbx2, nby2, nbz2)

! Copies 3D array from 3D storage to linear storage.
!
! Input:
! vec3d = complex array in 3D storage
! nbx2,nby2,nbz2 = dimensions of 3D array
! Output:
! vec1d = real array in linear storage
!

    USE params
    IMPLICIT NONE

    REAL(DP), INTENT(IN) ::coef
    INTEGER, INTENT(IN) :: nbx2
    INTEGER, INTENT(IN) :: nby2
    INTEGER, INTENT(IN) :: nbz2
    COMPLEX(C_DOUBLE_COMPLEX), INTENT(IN) :: vec3d(nbx2, nby2, nbz2)
    REAL(DP), INTENT(OUT) :: vec1d(kdfull2)

    INTEGER:: i1, i2, i3, ind

    ind = 0
    DO i3 = 1, nbz2
      DO i2 = 1, nby2
        DO i1 = 1, nbx2
          ind = ind + 1
          vec1d(ind) = REAL(vec3d(i1, i2, i3), DP)*coef
        END DO
      END DO
    END DO

    RETURN
  END SUBROUTINE copyr3dto1d

! ******************************

  SUBROUTINE secopy3dto1d(vec3d, vec1d, coef, nbx2, nby2, nbz2)

! Copies 3D array from 3D storage to linear storage (both COMPLEX).
!
! Input:
! vec3d = array in 3D storage
! nbx2,nby2,nbz2 = dimensions of 3D array
! Output:
! vec1d = array in linear storage
!
! Does the same as 'copy1dto3d' but with faster (?) index computation.

    USE params
    IMPLICIT NONE

    REAL(DP), INTENT(IN) ::coef
    INTEGER, INTENT(IN) :: nbx2
    INTEGER, INTENT(IN) :: nby2
    INTEGER, INTENT(IN) :: nbz2
    COMPLEX(C_DOUBLE_COMPLEX), INTENT(IN) :: vec3d(nbx2, nby2, nbz2)
    COMPLEX(DP), INTENT(OUT) :: vec1d(kdfull2)

    INTEGER:: i1, i2, i3, ind

    ind = 0
    DO i3 = 1, nbz2
      DO i2 = 1, nby2
        DO i1 = 1, nbx2
          ind = ind + 1
          vec1d(ind) = vec3d(i1, i2, i3)*coef
        END DO
      END DO
    END DO

    RETURN
  END SUBROUTINE secopy3dto1d

! ******************************

  SUBROUTINE fft_end()

! FFTW epilogue.

    USE FFTW
    IMPLICIT NONE

    CALL fftw_destroy_plan(pforw(0))
    CALL fftw_destroy_plan(pback(0))
    CALL fftw_destroy_plan(pforwx)
    CALL fftw_destroy_plan(pforwy)
    CALL fftw_destroy_plan(pforwz)
    CALL fftw_destroy_plan(pforwz1)
    CALL fftw_destroy_plan(pbackx)
    CALL fftw_destroy_plan(pbacky)
    CALL fftw_destroy_plan(pbackz)
    CALL fftw_destroy_plan(pbackz1)

    DEALLOCATE (ak, akv)
    DEALLOCATE (akpropx, akpropy, akpropz)
    DEALLOCATE (fftax, fftay, fftaz, fftb, ffta)

    RETURN
  END SUBROUTINE fft_end

! END BLOCK of subroutines for FFTW3
#endif

! ******************************
#if(netlib_fft)
! BLOCK of subroutines for NETLIB
! ******************************

  SUBROUTINE kinprop(q1, q2)

! ******************************

! Propagation with kinetic energy exp(-i*dt*e_kin).
!
! Input/Output:
! q1 = coordinate-space array for propagated wavefunction
! q2 = complex wavefunction array as workspace

    USE params

    IMPLICIT NONE

    COMPLEX(DP), INTENT(IN OUT) :: q1(kdfull2)
    COMPLEX(DP), INTENT(OUT) :: q2(kdfull2)

    INTEGER, SAVE :: nxini = 0, nyini = 0, nzini = 0 ! flag for initialization
    REAL(DP), ALLOCATABLE :: ffttax(:), ffttay(:), ffttaz(:), ffttb(:, :) ! Complexes stored in real arrays for NETLIB FFT library
    INTEGER:: i1, i2, i3, i1m, i2m, i3m, ind
    INTEGER :: ic, ir ! Index for real and complex components when stored in ffttax, fftay...
    COMPLEX(DP) :: cmplxfac
    REAL(DP):: tnorm, xfnorm, yfnorm, zfnorm

    LOGICAL, PARAMETER :: ttimestop = .TRUE.
    REAL(DP) :: acctime(1:10)
    INTEGER :: it1, it2, it3, it4, it5, it6

    CALL fftf(q1, q2)
    q2(1:kdfull2) = ak*q2(1:kdfull2)
    CALL fftback(q2, q1)

    RETURN
  END SUBROUTINE kinprop

  SUBROUTINE xgradient_rspace(fin, gradfout)

! The gradient of the complex field 'fin' in x-direction.
! The fields are given in coordinate space. The gradient is
! evaluated in k_x space.
!

    USE params
    IMPLICIT NONE

    COMPLEX(DP), INTENT(IN) :: fin(kdfull2)
    COMPLEX(DP), INTENT(OUT) :: gradfout(kdfull2)

    INTEGER:: i1, i2, i3, ind
    INTEGER:: ic, ir
    REAL(DP):: dkx, zkx
! ************************************************************

    dkx = pi/(dx*nx)
    DO i3 = 1, nz2
      DO i2 = 1, ny2
! forward transform along x
        DO i1 = 1, nx2
          ind = (i3 - 1)*nxyf + (i2 - 1)*nyf + i1
#if(extended)
! ic=2*modx(i1)
#endif
          ic = 2*i1
          ir = ic - 1
          cfftax(modx(i1)) = fin(ind)
! fftax(ir)=REAL(fin(ind),DP) ! copy to workspace
! fftax(ic)=AIMAG(fin(ind)) ! copy to workspace
        END DO
        CALL dcftf1(nx2, fftax, wrkx, wsavex, ifacx) ! basic fft
! multiply by k_x factor in k_x space
        DO i1 = 1, nx2
          IF (i1 == (nx + 1)) THEN
            zkx = 0D0
          ELSE IF (i1 > (nx + 1)) THEN
            zkx = (i1 - nx2 - 1)*dkx
          ELSE
            zkx = (i1 - 1)*dkx
          END IF
          ic = 2*i1
          ir = ic - 1
          cfftax(i1) = cfftax(i1)*eye*zkx
#if(extended)
! fftax(ir) = -fftax(ic)*zkx ! *eye*zkx
! fftax(ic) = fftax(ir)*zkx
#endif
        END DO
! backward transform along x
        CALL dcftb1(nx2, fftax, wrkx, wsavex, ifacx)
        DO i1 = 1, nx2
          ind = (i3 - 1)*nxyf + (i2 - 1)*nyf + i1
#if(extended)
! ic=2*modx(i1)
#endif
          ic = 2*i1
          ir = ic - 1
#if(extended)
! gradfout(ind)= CMPLX(fftax(ir), fftax(ic),DP)/nx2
#endif
          gradfout(ind) = cfftax(modx(i1))/nx2
        END DO
      END DO
    END DO

    RETURN

  END SUBROUTINE xgradient_rspace

  SUBROUTINE ygradient_rspace(fin, gradfout)

! The gradient of the complex field 'fin' in y-direction.
! The fields are given in coordinate space. The gradient is
! evaluated in k_y space.
!

    USE params
    IMPLICIT NONE

    COMPLEX(DP), INTENT(IN) :: fin(kdfull2)
    COMPLEX(DP), INTENT(OUT) :: gradfout(kdfull2)

    INTEGER:: ic, ir
    INTEGER:: i1, i2, i3, ind
    REAL(DP):: dky, zky
! ************************************************************

    dky = pi/(dy*ny)
    DO i3 = 1, nz2
      DO i1 = 1, nx2
! forward transform along y
        DO i2 = 1, ny2
          ind = (i3 - 1)*nxyf + (i2 - 1)*nyf + i1
          ic = 2*i2
          ir = ic - 1
          cfftay(i2) = fin(ind)
        END DO
        CALL dcftf1(ny2, fftay, wrky, wsavey, ifacy)
! multiply by k_y factor in k_y space
        DO i2 = 1, ny2
          IF (i2 == (ny + 1)) THEN
            zky = 0D0
          ELSE IF (i2 > (ny + 1)) THEN
            zky = (i2 - ny2 - 1)*dky
          ELSE
            zky = (i2 - 1)*dky
          END IF
          ic = 2*i2
          ir = ic - 1
          cfftay(i2) = cfftay(i2)*eye*zky
        END DO
! backward transform along y
        CALL dcftb1(ny2, fftay, wrky, wsavey, ifacy)
        DO i2 = 1, ny2
          ind = (i3 - 1)*nxyf + (i2 - 1)*nyf + i1
          ic = 2*i2
          ir = ic - 1
! gradfout(ind)= CMPLX(fftay(ir), fftay(ic), DP)/ny2
          gradfout(ind) = cfftay(i2)/ny2
        END DO
      END DO
    END DO

    RETURN

  END SUBROUTINE ygradient_rspace

  SUBROUTINE zgradient_rspace(fin, gradfout)

! The gradient of the complex field 'fin' in z-direction.
! The fields are given in coordinate space. The gradient is
! evaluated in k_z space.
!

    USE params
    IMPLICIT NONE

    COMPLEX(DP), INTENT(IN) :: fin(kdfull2)
    COMPLEX(DP), INTENT(OUT) :: gradfout(kdfull2)

    INTEGER:: ic, ir
    INTEGER:: i1, i2, i3, i3m, ind
    REAL(DP):: dkz, zkz

! ************************************************************


    dkz = pi/(dz*nz)
    DO i2 = 1, ny2
      DO i1 = 1, nx2
! forward transform along z
        DO i3 = 1, nz2
          ind = (i3 - 1)*nxyf + (i2 - 1)*nyf + i1
          i3m = MOD(i3 + nz, nz2) + 1
          ic = 2*i3
          ir = ic - 1
          cfftaz(i3m) = fin(ind)
        END DO
        CALL dcftf1(nz2, fftaz, wrkz, wsavez, ifacz)
! multiply by k_z factor in k_z space
        DO i3 = 1, nz2
          IF (i3 == (nz + 1)) THEN
            zkz = 0D0
          ELSE IF (i3 > (nz + 1)) THEN
            zkz = (i3 - nz2 - 1)*dkz
          ELSE
            zkz = (i3 - 1)*dkz
          END IF
          ic = 2*i3
          ir = ic - 1
          cfftaz(i3) = cfftaz(i3)*eye*zkz
        END DO
! backward transform along z
        CALL dcftb1(nz2, fftaz, wrkz, wsavez, ifacz)
        DO i3 = 1, nz2 ! copy back
          ind = (i3 - 1)*nxyf + (i2 - 1)*nyf + i1
          i3m = MOD(i3 + nz, nz2) + 1
          ic = 2*i3
          ir = ic - 1
          gradfout(ind) = cfftaz(i3m)/nz2
        END DO
!
      END DO
    END DO

    RETURN

  END SUBROUTINE zgradient_rspace

  SUBROUTINE fftf(q1, q2)

! Forward 3D FFT from 'q1' in r-space to 'q2' in k-space.

    USE params
    IMPLICIT NONE

    COMPLEX(DP), INTENT(IN) :: q1(kdfull2)
    COMPLEX(DP), INTENT(OUT) :: q2(kdfull2)

    INTEGER:: i1, i2, i3, i3m, ind
    INTEGER:: ic, ir
    REAL(DP):: tnorm

    INTEGER, SAVE :: nxini = 0, nyini = 0, nzini = 0 ! flag for initialization

    tnorm = 1D0/SQRT(8D0*pi*pi*pi*REAL(nx2*ny2*nz2, DP))

! check initialization

    IF (nxini == 0) THEN
      CALL dcfti1(nx2, wsavex, ifacx)
      nxini = nx2
    ELSE IF (nxini /= nx2) THEN
      STOP ' nx2 in four3d not as initialized!'
    END IF
    IF (nyini == 0) THEN
      CALL dcfti1(ny2, wsavey, ifacy)
      nyini = ny2
    ELSE IF (nyini /= ny2) THEN
      STOP ' ny2 in four3d not as initialized!'
    END IF
    IF (nzini == 0) THEN
      CALL dcfti1(nz2, wsavez, ifacz)
      nzini = nz2
    ELSE IF (nzini /= nz2) THEN
      STOP ' nz2 in four3d not as initialized!'
    END IF

! transformation in x-direction

    DO i3 = 1, nz2
      DO i2 = 1, ny2
        DO i1 = 1, nx2
          ind = (i3 - 1)*nxyf + (i2 - 1)*nyf + i1
          ic = 2*modx(i1)
          ir = ic - 1
          fftax(ir) = REAL(q1(ind), DP) ! copy to workspace
          fftax(ic) = AIMAG(q1(ind))
        END DO
        CALL dcftf1(nx2, fftax, wrkx, wsavex, ifacx) ! basic fft
        DO i1 = 1, nx2
          ind = (i3 - 1)*nxyf + (i2 - 1)*nyf + i1
          ic = 2*i1
          ir = ic - 1
          q2(ind) = CMPLX(fftax(ir), fftax(ic), DP) ! copy back in strange order
        END DO
      END DO
    END DO

! transformation in y-direction

    DO i3 = 1, nz2
      DO i1 = 1, nx2
        DO i2 = 1, ny2
          ind = (i3 - 1)*nxyf + (i2 - 1)*nyf + i1
          ic = 2*mody(i2)
          ir = ic - 1
          fftay(ir) = REAL(q2(ind), DP)
          fftay(ic) = AIMAG(q2(ind))
        END DO
        CALL dcftf1(ny2, fftay, wrky, wsavey, ifacy)
        DO i2 = 1, ny2
          ind = (i3 - 1)*nxyf + (i2 - 1)*nyf + i1
          ic = 2*i2
          ir = ic - 1
          q2(ind) = CMPLX(fftay(ir), fftay(ic), DP)
        END DO
      END DO
    END DO

! transformation in z-direction

    DO i2 = 1, ny2
      DO i3 = 1, nz2
        i3m = MOD(i3 + nz, nz2) + 1
        ic = 2*i3m
        ir = ic - 1
        DO i1 = 1, nx2
          ind = (i3 - 1)*nxyf + (i2 - 1)*nyf + i1
          fftb(ir, i1) = REAL(q2(ind), DP)
          fftb(ic, i1) = AIMAG(q2(ind))
        END DO
      END DO
      DO i1 = 1, nx2
        CALL dcftf1(nz2, fftb(:, i1), wrkz, wsavez, ifacz)
      END DO
      DO i3 = 1, nz2
        ic = 2*i3
        ir = ic - 1
        DO i1 = 1, nx2
          ind = (i3 - 1)*nxyf + (i2 - 1)*nyf + i1
          q2(ind) = tnorm*CMPLX(fftb(ir, i1), fftb(ic, i1), DP)
        END DO
      END DO
    END DO

    RETURN
  END SUBROUTINE fftf

  SUBROUTINE fftback(q1, q2)

! Backward 3D FFT from 'q1' in k-space to 'q2' in r-space.

    USE params
    IMPLICIT NONE

    COMPLEX(DP), INTENT(IN) :: q1(kdfull2)
    COMPLEX(DP), INTENT(OUT) :: q2(kdfull2)
    INTEGER:: i1, i2, i3, i3m, ind
    INTEGER:: ic, ir
    REAL(DP):: facnr

    facnr = SQRT(8D0*pi*pi*pi)/SQRT(REAL(nx2*ny2*nz2, DP))

! transformation in z-direction
    DO i2 = 1, ny2
      DO i3 = 1, nz2
        ic = 2*i3
        ir = ic - 1
        DO i1 = 1, nx2
          ind = (i3 - 1)*nxyf + (i2 - 1)*nyf + i1
          fftb(ir, i1) = facnr*REAL(q1(ind), DP)
          fftb(ic, i1) = facnr*AIMAG(q1(ind))
        END DO
      END DO
      DO i1 = 1, nx2
        CALL dcftb1(nz2, fftb(:, i1), wrkz, wsavez, ifacz) ! basic fft
      END DO
      DO i3 = 1, nz2 ! copy back
        i3m = MOD(i3 + nz, nz2) + 1
        ic = 2*i3m
        ir = ic - 1
        DO i1 = 1, nx2
          ind = (i3 - 1)*nxyf + (i2 - 1)*nyf + i1
          q2(ind) = CMPLX(fftb(ir, i1), fftb(ic, i1), DP)
        END DO
      END DO
    END DO

! transformation in y-direction

    DO i3 = 1, nz2
      DO i1 = 1, nx2
        DO i2 = 1, ny2
          ind = (i3 - 1)*nxyf + (i2 - 1)*nyf + i1
          ic = 2*i2
          ir = ic - 1
          fftay(ir) = REAL(q2(ind), DP)
          fftay(ic) = AIMAG(q2(ind))
        END DO
        CALL dcftb1(ny2, fftay, wrky, wsavey, ifacy)
        DO i2 = 1, ny2
          ind = (i3 - 1)*nxyf + (i2 - 1)*nyf + i1
          ic = 2*mody(i2)
          ir = ic - 1
          q2(ind) = CMPLX(fftay(ir), fftay(ic), DP)
        END DO
      END DO
    END DO

! transformation in x-direction

    DO i3 = 1, nz2
      DO i2 = 1, ny2
        DO i1 = 1, nx2
          ind = (i3 - 1)*nxyf + (i2 - 1)*nyf + i1
          ic = 2*i1
          ir = ic - 1
          fftax(ir) = REAL(q2(ind), DP)
          fftax(ic) = AIMAG(q2(ind))
        END DO
        CALL dcftb1(nx2, fftax, wrkx, wsavex, ifacx)
        DO i1 = 1, nx2
          ind = (i3 - 1)*nxyf + (i2 - 1)*nyf + i1
          ic = 2*modx(i1)
          ir = ic - 1
          q2(ind) = CMPLX(fftax(ir), fftax(ic), DP)
        END DO
      END DO
    END DO

    RETURN
  END SUBROUTINE fftback

  SUBROUTINE rftf(q1, q2)

! Forward 3D FFT from real r-space array 'q1' to complex k-space 'q2'.

    USE params
    IMPLICIT NONE

    REAL(DP), INTENT(IN) :: q1(kdfull2)
    COMPLEX(DP), INTENT(OUT) :: q2(kdfull2)

    INTEGER, SAVE :: nxini = 0, nyini = 0, nzini = 0 ! flag for initialization
    INTEGER:: i1, i2, i3, ind
    INTEGER:: ic, ir
    REAL(DP):: tnorm

    tnorm = 1D0/SQRT(8D0*pi*pi*pi*REAL(nx2*ny2*nz2, DP))

! check initialization
    IF (nxini == 0) THEN
      CALL dcfti1(nx2, wsavex, ifacx)
      nxini = nx2
    ELSE IF (nxini /= nx2) THEN
      STOP ' nx2 in four3d not as initialized!'
    END IF
    IF (nyini == 0) THEN
      CALL dcfti1(ny2, wsavey, ifacy)
      nyini = ny2
    ELSE IF (nyini /= ny2) THEN
      STOP ' ny2 in four3d not as initialized!'
    END IF
    IF (nzini == 0) THEN
      CALL dcfti1(nz2, wsavez, ifacz)
      nzini = nz2
    ELSE IF (nzini /= nz2) THEN
      STOP ' nz2 in four3d not as initialized!'
    END IF

! transformation in x-direction

    DO i3 = 1, nz2
      DO i2 = 1, ny2
        DO i1 = 1, nx2
          ind = (i3 - 1)*nxyf + (i2 - 1)*nyf + i1
          ic = 2*modx(i1)
          ir = ic - 1
          fftax(ir) = q1(ind) ! copy to workspace
          fftax(ic) = 0D0
        END DO
        CALL dcftf1(nx2, fftax, wrkx, wsavex, ifacx) ! basic fft
        DO i1 = 1, nx2
          ind = (i3 - 1)*nxyf + (i2 - 1)*nyf + i1
          ic = 2*i1
          ir = ic - 1
          q2(ind) = CMPLX(fftax(ir), fftax(ic), DP) ! copy back in strange order
        END DO
      END DO
    END DO

! transformation in y-direction

    DO i3 = 1, nz2
      DO i1 = 1, nx2
        DO i2 = 1, ny2
          ind = (i3 - 1)*nxyf + (i2 - 1)*nyf + i1
          ic = 2*mody(i2)
          ir = ic - 1
          fftay(ir) = REAL(q2(ind), DP)
          fftay(ic) = AIMAG(q2(ind))
        END DO
        CALL dcftf1(ny2, fftay, wrky, wsavey, ifacy)
        DO i2 = 1, ny2
          ind = (i3 - 1)*nxyf + (i2 - 1)*nyf + i1
          ic = 2*i2
          ir = ic - 1
          q2(ind) = CMPLX(fftay(ir), fftay(ic), DP)
        END DO
      END DO
    END DO

! transformation in z-direction

    DO i2 = 1, ny2
      DO i3 = 1, nz2
        ic = 2*modz(i3)
        ir = ic - 1
        DO i1 = 1, nx2
          ind = (i3 - 1)*nxyf + (i2 - 1)*nyf + i1
          fftb(ir, i1) = REAL(q2(ind), Dp)
          fftb(ic, i1) = AIMAG(q2(ind))
        END DO
      END DO
      DO i1 = 1, nx2
        CALL dcftf1(nz2, fftb(1, i1), wrkz, wsavez, ifacz)
      END DO
      DO i3 = 1, nz2
        ic = 2*i3
        ir = ic - 1
        DO i1 = 1, nx2
          ind = (i3 - 1)*nxyf + (i2 - 1)*nyf + i1
          q2(ind) = tnorm*CMPLX(fftb(ir, i1), fftb(ic, i1), DP)
        END DO
      END DO
    END DO

    RETURN
  END SUBROUTINE rftf

  SUBROUTINE rfftback(q1, q3)

! Backward 3D FFT from complex k-space 'q1' to real r-space array 'q3'.

    USE params
    IMPLICIT NONE

    COMPLEX(DP), INTENT(IN) :: q1(kdfull2)
    REAL(DP), INTENT(OUT) :: q3(kdfull2)

    COMPLEX(DP), ALLOCATABLE :: q2(:)
    INTEGER :: i1, i2, i3, ind
    INTEGER :: ir, ic
    REAL(DP):: facnr

#if(extended)
! DATA nxini,nyini,nzini/0,0,0/ ! flag for initialization
! nxyf=nx2*ny2
! nyf=nx2
! nx=nx2/2
! ny=ny2/2
! nz=nz2/2
#endif

    facnr = SQRT(8D0*pi*pi*pi)/SQRT(REAL(nx2*ny2*nz2, DP))

    ALLOCATE (q2(kdfull2))

! transformation in z-direction

    DO i2 = 1, ny2
      DO i3 = 1, nz2
        ic = 2*i3
        ir = ic - 1
        DO i1 = 1, nx2
          ind = (i3 - 1)*nxyf + (i2 - 1)*nyf + i1
          fftb(ir, i1) = facnr*REAL(q1(ind), DP)
          fftb(ic, i1) = facnr*AIMAG(q1(ind))
        END DO
      END DO
      DO i1 = 1, nx2
        CALL dcftb1(nz2, fftb(:, i1), wrkz, wsavez, ifacz) ! basic fft
      END DO
      DO i3 = 1, nz2 ! copy back
        ic = 2*modz(i3)
        ir = ic - 1
        DO i1 = 1, nx2
          ind = (i3 - 1)*nxyf + (i2 - 1)*nyf + i1
          q2(ind) = CMPLX(fftb(ir, i1), fftb(ic, i1), DP)
        END DO
      END DO
    END DO

! transformation in y-direction

    DO i3 = 1, nz2
      DO i1 = 1, nx2
        DO i2 = 1, ny2
          ind = (i3 - 1)*nxyf + (i2 - 1)*nyf + i1
          ic = 2*i2
          ir = ic - 1
          fftay(ir) = REAL(q2(ind), DP)
          fftay(ic) = AIMAG(q2(ind))
        END DO
        CALL dcftb1(ny2, fftay, wrky, wsavey, ifacy)
        DO i2 = 1, ny2
          ind = (i3 - 1)*nxyf + (i2 - 1)*nyf + i1
          ic = 2*mody(i2)
          ir = ic - 1
          q2(ind) = CMPLX(fftay(ir), fftay(ic), DP)
        END DO
      END DO
    END DO

! transformation in x-direction

    DO i3 = 1, nz2
      DO i2 = 1, ny2
        DO i1 = 1, nx2
          ind = (i3 - 1)*nxyf + (i2 - 1)*nyf + i1
          ic = 2*i1
          ir = ic - 1
          fftax(ir) = REAL(q2(ind), DP)
          fftax(ic) = AIMAG(q2(ind))
        END DO
        CALL dcftb1(nx2, fftax, wrkx, wsavex, ifacx)
        DO i1 = 1, nx2
          ind = (i3 - 1)*nxyf + (i2 - 1)*nyf + i1
          ir = 2*modx(i1) - 1
          q3(ind) = fftax(ir)
        END DO
      END DO
    END DO

    DEALLOCATE (q2)

    RETURN
  END SUBROUTINE rfftback

! END BLOCK of subroutines for NETLIB
#endif

END MODULE kinetic
